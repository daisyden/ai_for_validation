
Pytorch sepcific information extraction:
1. **Identify the test module**:
   - According to the test file path and issue body categorize the test into one of:
     - `torch operation` (aten ops)
     - `distributed` (multi-process/device)
     - `runtime` (execution environment)
     - `inductor` (compiler)
     - `torchbench` (benchmarking)
     - `functorch` (functional transformations)
     - `dynamo` (graph capture and optimization)
     - `export` (model export)
     - `distributions` (probabilistic programming)
     - `quantization` (model quantization)
     - `profile` (performance profiling)
     - `optim` (optimization algorithms)
     - `fx` (functional transforms)
2. **Extract the data type (`dtype`)**:
    - Identify the data type involved in the test failure (e.g., `float32`, `int64`, `bool`, etc.) from test case name, the traceback or error message.
3. **Extract the torch operation (`torch_op`)**:
   - Identify the specific PyTorch operation involved in the test failure (e.g., `add`, `matmul`, `conv2d`, `positive`, etc.) from the test case name, traceback or error message. If not applicable, return `None`.
   - The test case name is usually parameterized based on original test name, with torch operation, dtypes, devices and other features as parameters. For example:
     - `test_compare_cpu_positive_xpu_float32` -> torch_op is `positive`, dtype is `float32`
     - `test_errors_add_int64` -> torch_op is `add`, dtype is `int64` 
4. ""The dependency is empty"".