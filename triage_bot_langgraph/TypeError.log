User: User: You are an expert QA engineer analyzing a failure in the `torch-xpu-ops` unit test. Below is the failure log:

Torch-xpu-ops unit test class 
<test_class>
TestFusedObsFakeQuantXPU
</test_class>

test case 
<test_case>
test_fused_obs_fake_quant_moving_avg_per_channel_xpu 
</test_case>

returned failure with error message: 
<error_message>
TypeError: accept..test_fused_obs_fake_quant_moving_avg_per_channel() missing 1 required positional argument: 'use_bool'
</error_message> . 

The test file is 
<test_file>
test/xpu/quantization/core/test_workflow_ops_xpu.py
</test_file>

and as a wrapper file it calls code in the base test file 
<base_test_file>
../../../test/quantization/core/test_workflow_ops.py
</base_test_file>
.\n

The test tmux enviroment is 
<tmux>
python_test
</tmux>

1. **Extract the test case name**:
   - Identify the full test case name starting with `test_` from the failure log.

    ```
2. **Determine the original test case**:
   - If the test is parameterized (e.g., `test_compare_cpu__batch_norm_with_update_xpu_bool`), extract the base test name (e.g., `test_compare_cpu`).
   - Verify by checking the test file:
     <base_test_file>
     ../../../test/quantization/core/test_workflow_ops.py
     </base_test_file>
     at repo 
     ```
     https://raw.githubusercontent.com/pytorch/pytorch/refs/heads/main
     ```
3. **Identify the test module**:
   - Categorize the test into one of:
     - `torch operation` (core ops)
     - `distributed` (multi-process/device)
     - `runtime` (execution environment)
     - `inductor` (compiler)
     - `torchbench` (benchmarking)

4. **Extract the data type (`dtype`)**:
   - Infer from test name/trace (e.g., `xpu_bool` → `bool`, `f32` → `float32`).

5. **Resolve the torch operation or tensor info**:
   - **If parameterized**: Parse the op name from the test case (e.g., `batch_norm` from `...batch_norm...`), the op name is usually right after the base test name.
   - **Otherwise**: Trace the failure in 
     <base_test_file>
     ../../../test/quantization/core/test_workflow_ops.py
     </base_test_file>
     to find the tensor/op (ignore backends like `xpu/cpu`).

6. **Classify the error type**:
   - `AssertionError` (test condition failed)
   - `RuntimeError` (execution crash)
   - `FatalError` (critical system error)
   - Other (specify).

7. **Extract the error message**:
   - Copy the raw error message (exclude stack traces unless critical).

Please return a beutified JSON with the following structure, only return the json and not output other text:
```json
{
  "base_test_file": "../../../test/quantization/core/test_workflow_ops.py",
  "test_file": "test/xpu/quantization/core/test_workflow_ops_xpu.py"
  "test_case": "test_fused_obs_fake_quant_moving_avg_per_channel_xpu",
  "original_test_case": "base_test_name",
  "module": "torch operation/distributed/runtime/inductor/torchbench",
  "dtype": "float32/bool/int64/etc",
  "torch_op": "op_name_or_None",
  "error_type": "AssertionError/RuntimeError/etc",
  "error_message": "Raw error text"
  "tmux": "The tmux session"
}
```

Assistant: ```json
{
  "base_test_file": "../../../test/quantization/core/test_workflow_ops.py",
  "test_file": "test/xpu/quantization/core/test_workflow_ops_xpu.py",
  "test_case": "test_fused_obs_fake_quant_moving_avg_per_channel_xpu",
  "original_test_case": "test_fused_obs_fake_quant_moving_avg_per_channel",
  "module": "torch operation",
  "dtype": "None",
  "torch_op": "fused_obs_fake_quant",
  "error_type": "TypeError",
  "error_message": "TypeError: accept..test_fused_obs_fake_quant_moving_avg_per_channel() missing 1 required positional argument: 'use_bool'",
  "tmux": "python_test"
}
```
User: 